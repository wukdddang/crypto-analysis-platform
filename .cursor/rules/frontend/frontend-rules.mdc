---
description:
globs:
alwaysApply: false
---

비트코인 익스플로러 개발을 진행하려고 해.

Nextjs 14 + SWR + pnpm 을 사용해줘.

# React Context 작성 규칙

## 1. Context 파일 구조 및 네이밍

### 파일 위치

- Context 파일은 해당 페이지 폴더 내 `_context/` 디렉토리에 위치
- 파일명: `{page-name}Context.tsx` 형식
- 예시: `project-management.context.tsx`, `my-attendance.context.tsx`

### 폴더 구조

```
src/app/(planning)/plan/(user)/user/{page-name}/
├── _context/
│   └── {page-name}.context.tsx
├── _ui/
│   ├── {component-name}.panel/
│   ├── {component-name}.section/
│   ├── {component-name}.module.tsx
│   └── {component-name}.component.tsx
├── _hooks/ (선택적)
│   └── use-{hook-name}.ts
└── page.tsx
```

### 인터페이스 네이밍

- Context 타입 인터페이스: `{PageName}ContextType`
- Provider Props 인터페이스: `{PageName}ProviderProps`

## 2. 함수 네이밍 규칙

### 액션 함수 네이밍

- **한국어 동사형**으로 작성
- `~한다` 형태로 끝나는 동사형 사용
- 예시:
  - `fetchWBSItems` → `WBS_항목을_조회_한다`
  - `submitEvaluation` → `평가를_제출_한다`
  - `saveAllEvaluations` → `모든_평가를_임시_저장_한다`

### 핸들러 함수 네이밍

- `handle` + `동작명` 형태
- 예시: `handleEvaluationChange`, `handleSubmitEvaluation`

## 3. Context 구조

### Context와 Route Handler 연결

Context는 Route Handler에 연결하여 데이터를 받아오고, 이를 value로 반환합니다:

1. **Context**: Route Handler API를 호출하여 데이터를 가져옴
2. **Route Handler**: 데이터베이스 조회/수정 로직 처리
3. **컴포넌트**: Context의 커스텀 훅을 호출하여 데이터 사용

### 데이터 흐름

```
Route Handler (/api/...) ← Context (API 호출) → 컴포넌트 (훅 사용)
```

### 상태 그룹화

```typescript
interface ContextType {
  // 데이터 상태 (Route Handler에서 받은 데이터)
  dataItems: DataType[];
  loading: boolean;
  error: string | null;

  // 액션 함수들 (Route Handler 호출)
  데이터를_조회_한다: () => Promise<void>;
  데이터를_제출_한다: (data: DataType) => Promise<boolean>;

  // 상태 업데이트 함수들
  setDataItems: React.Dispatch<React.SetStateAction<DataType[]>>;
}
```

### Provider 구조

```typescript
export const PageProvider: React.FC<PageProviderProps> = ({ children }) => {
  // 데이터 상태 (Route Handler에서 받은 데이터를 저장)
  const [dataItems, setDataItems] = useState<DataType[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 액션 함수들 (Route Handler API 호출)
  const 데이터를_조회_한다 = async () => {
    setLoading(true);
    setError(null);

    try {
      // Route Handler API 호출
      const response = await fetch("/api/plan/page-name/mount");
      const result = await response.json();

      if (result.success) {
        setDataItems(result.data); // Route Handler에서 받은 데이터 저장
      } else {
        throw new Error(result.message || "데이터 조회에 실패했습니다.");
      }
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "알 수 없는 오류가 발생했습니다."
      );
      console.error("API 호출 오류:", err);
    } finally {
      setLoading(false);
    }
  };

  // 컴포넌트 마운트 시 Route Handler에서 데이터 로드
  useEffect(() => {
    데이터를_조회_한다();
  }, []);

  // Context value로 Route Handler 데이터와 액션 함수들 제공
  const contextValue: ContextType = {
    dataItems, // Route Handler에서 받은 데이터
    loading, // API 호출 상태
    error, // 에러 상태
    데이터를_조회_한다, // Route Handler 호출 함수
    setDataItems, // 데이터 업데이트 함수
  };

  return <Context.Provider value={contextValue}>{children}</Context.Provider>;
};
```

## 4. 페이지 상태 관리

### 페이지별 상태 분리

- **Context**: 데이터 관련 상태와 API 함수들만 관리
- **Page Component**: 페이지 UI 상태들 관리
  - 필터링 상태 (selectedYear, selectedHalf 등)
  - 네비게이션 상태 (currentIndex 등)
  - UI 상호작용 상태

### 페이지 컴포넌트 구조

```typescript
function PageContent() {
  // Context의 커스텀 훅을 호출하여 Route Handler에서 받은 데이터 사용
  const {
    dataItems,        // Route Handler에서 받은 데이터
    loading,          // API 호출 상태
    데이터를_조회_한다, // Route Handler 호출 함수
    setDataItems,     // 데이터 업데이트 함수
  } = usePageContext();

  // 페이지 UI 상태들 (Context와 분리)
  const [selectedYear, setSelectedYear] = useState(currentYear);
  const [selectedHalf, setSelectedHalf] = useState<"first" | "second">(currentHalf);

  // 페이지 상태 변경 시 Route Handler 재호출
  useEffect(() => {
    데이터를_조회_한다(selectedYear, selectedHalf);
  }, [selectedYear, selectedHalf, 데이터를_조회_한다]);

  // UI 상호작용 핸들러
  const handleDataChange = useCallback((id: string, value: string) => {
    setDataItems(prev => ({ ...prev, [id]: value }));
  }, [setDataItems]);

  return (
    // JSX - Route Handler에서 받은 데이터를 렌더링
  );
}

export default function Page() {
  return (
    <PageProvider>  {/* Context Provider로 Route Handler 데이터 제공 */}
      <PageContent />
    </PageProvider>
  );
}
```

## 5. 커스텀 훅

### 훅 네이밍

- `use{PageName}` 형태
- 예시: `useSelfEvaluation`, `useProjectManagement`
- 파일명: `use{HookName}.ts` 형태

### 에러 처리

```typescript
export const usePage = () => {
  const context = useContext(PageContext);
  if (context === undefined) {
    throw new Error("usePage must be used within a PageProvider");
  }
  return context; // Route Handler에서 받은 데이터와 액션 함수들 반환
};
```

### 사용 예시

```typescript
// 컴포넌트에서 Context 훅 사용
function MyComponent() {
  const { dataItems, loading, 데이터를_조회_한다 } = usePage();

  // Route Handler에서 받은 데이터 사용
  if (loading) return <div>로딩 중...</div>;

  return (
    <div>
      {dataItems.map((item) => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
}
```

## 6. UI 컴포넌트 구조

### 컴포넌트 네이밍 규칙

- **Panel**: 전체 화면을 차지하는 큰 컴포넌트
  - 예시: `project-table.panel/`, `attendance-timeline.panel/`
- **Section**: 페이지 내 특정 섹션
  - 예시: `project-detail.section/`
- **Module**: 재사용 가능한 기능 단위
  - 예시: `project-type-filter.module.tsx`, `project-tree.module.tsx`
- **Component**: 기본 UI 컴포넌트
  - 예시: `status-select.component.tsx`, `simple-status-select.component.tsx`

### 컴포넌트 파일 구조

```
_ui/
├── {component-name}.panel/
│   ├── index.tsx
│   └── {component-name}.module.css (선택적)
├── {component-name}.section/
│   ├── index.tsx
│   └── {component-name}.module.css (선택적)
├── {component-name}.module.tsx
└── {component-name}.component.tsx
```

## 7. API 호출 패턴

### 에러 처리

- try-catch 블록 사용
- setError로 에러 상태 관리
- console.error로 로깅

### 로딩 상태

- API 호출 시작 시 `setLoading(true)`
- finally 블록에서 `setLoading(false)`

### 응답 처리

```typescript
const response = await fetch("/api/endpoint");
const result = await response.json();

if (result.success) {
  setData(result.data);
} else {
  throw new Error(result.message || "API 호출에 실패했습니다.");
}
```

## 8. API 라우트 작성 규칙

### 페이지 경로와 API 경로 일관성

페이지 경로와 API 경로는 일관성을 유지해야 합니다:

- **페이지 URL**: `/plan/admin/department-management`
- **API URL**: `/api/admin/department-management`

### 라우트 구조

- **목록 조회**: `/api/{module}/{page}/mount/route.ts`
- **상세 CRUD**: `/api/{module}/{page}/[id]/route.ts`
- **기능별 액션**: `/api/{module}/{page}/{action}/route.ts`

### 기본 템플릿

```typescript
// mount/route.ts - 목록 조회
export async function GET(): Promise<NextResponse<DataType>> {
  try {
    // 데이터 조회 로직
    return NextResponse.json(data);
  } catch (error) {
    console.error("API 호출 오류:", error);
    return NextResponse.json(
      { error: "데이터를 조회하는 중 오류가 발생했습니다." },
      { status: 500 }
    );
  }
}

// [id]/route.ts - 상세 CRUD
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
): Promise<NextResponse<DataType | { error: string }>> {
  try {
    const id = parseInt(params.id);

    if (isNaN(id)) {
      return NextResponse.json(
        { error: "유효하지 않은 ID입니다." },
        { status: 400 }
      );
    }

    // 상세 데이터 조회 로직
    return NextResponse.json(data);
  } catch (error) {
    console.error("상세 정보 조회 중 오류 발생:", error);
    return NextResponse.json(
      { error: "상세 정보를 조회하는 중 오류가 발생했습니다." },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
): Promise<NextResponse<DataType | { error: string }>> {
  try {
    const id = parseInt(params.id);
    const body = await request.json();

    if (isNaN(id)) {
      return NextResponse.json(
        { error: "유효하지 않은 ID입니다." },
        { status: 400 }
      );
    }

    // 데이터 업데이트 로직
    return NextResponse.json(updatedData);
  } catch (error) {
    console.error("데이터 업데이트 중 오류 발생:", error);
    return NextResponse.json(
      { error: "데이터를 업데이트하는 중 오류가 발생했습니다." },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
): Promise<NextResponse<{ success: boolean } | { error: string }>> {
  try {
    const id = parseInt(params.id);

    if (isNaN(id)) {
      return NextResponse.json(
        { error: "유효하지 않은 ID입니다." },
        { status: 400 }
      );
    }

    // 데이터 삭제 로직
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("데이터 삭제 중 오류 발생:", error);
    return NextResponse.json(
      { error: "데이터를 삭제하는 중 오류가 발생했습니다." },
      { status: 500 }
    );
  }
}
```

### API 라우트 규칙

1. **에러 처리**: 모든 API 핸들러에 try-catch 사용
2. **매개변수 검증**: URL 매개변수 유효성 검사 필수
3. **한국어 에러 메시지**: 사용자 친화적인 한국어 에러 메시지
4. **타입 안전성**: NextResponse 제네릭으로 응답 타입 명시
5. **로깅**: console.error로 서버 로그 기록
6. **HTTP 상태 코드**: 적절한 HTTP 상태 코드 반환

### 응답 데이터 구조

```typescript
// 성공 응답
{
  data: T,
  success?: boolean,
  message?: string
}

// 에러 응답
{
  error: string,
  code?: string,
  details?: any
}

// 목록 응답
{
  items: T[],
  total: number,
  page?: number,
  limit?: number,
  lastUpdated: string
}
```

## 9. 타입 정의

### 타입 파일 위치

- `@/types/` 디렉토리에 관련 타입들을 정의
- 페이지별로 파일 분리 (예: `evaluation.ts`, `project.ts`)

### 타입 네이밍

- 인터페이스: `I{TypeName}` 또는 `{TypeName}`
- 타입: `{TypeName}Type`

## 10. 주석 작성

### 함수 주석

- 한국어로 간단한 설명
- 예시: `// WBS 항목 조회`, `// 평가 제출 API 호출`

### 섹션 주석

- 주요 섹션별로 주석으로 구분
- 예시: `// 데이터 상태`, `// 액션 함수들`, `// 상태 업데이트 함수들`

## 11. 파일 구조 예시

### 프론트엔드 구조 (실제 구조 반영)

```
src/app/(planning)/plan/(user)/user/all-projects/
├── _context/
│   └── project-management.context.tsx
├── _ui/
│   ├── project-table.panel/
│   ├── project-gantt.panel/
│   ├── project-detail.section/
│   ├── floating-view-selector.tsx
│   ├── project-type-filter.module.tsx
│   ├── simple-status-select.component.tsx
│   ├── status-select.component.tsx
│   ├── project-tree.module.tsx
│   ├── project-legend.module.tsx
│   └── project-table.module.tsx
└── page.tsx
```

### API 라우트 구조

```
src/app/api/plan/self-evaluation/
├── mount/
│   └── route.ts          # 목록 조회 (GET)
├── [id]/
│   └── route.ts          # 상세 CRUD (GET, PUT, DELETE)
├── submit/
│   └── route.ts          # 평가 제출 (POST)
└── history/
    └── route.ts          # 이력 조회 (GET)
```

## 12. 실제 구현 예시

### Context 파일 예시

```typescript
// _context/project-management.context.tsx
import React, { createContext, useContext, useState, useEffect } from "react";

interface ProjectManagementContextType {
  projects: Project[];
  loading: boolean;
  error: string | null;
  프로젝트_목록을_조회_한다: () => Promise<void>;
  프로젝트를_생성_한다: (project: CreateProjectData) => Promise<boolean>;
  setProjects: React.Dispatch<React.SetStateAction<Project[]>>;
}

const ProjectManagementContext = createContext<
  ProjectManagementContextType | undefined
>(undefined);

export const ProjectManagementProvider: React.FC<{
  children: React.ReactNode;
}> = ({ children }) => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const 프로젝트_목록을_조회_한다 = async () => {
    setLoading(true);
    setError(null);

    try {
      // 페이지 경로: /plan/user/all-projects → API 경로: /api/plan/all-projects
      const response = await fetch("/api/plan/all-projects/mount");
      const result = await response.json();

      if (result.success) {
        setProjects(result.data);
      } else {
        throw new Error(result.message || "프로젝트 목록 조회에 실패했습니다.");
      }
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "알 수 없는 오류가 발생했습니다."
      );
      console.error("프로젝트 목록 조회 오류:", err);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    프로젝트_목록을_조회_한다();
  }, []);

  const contextValue: ProjectManagementContextType = {
    projects,
    loading,
    error,
    프로젝트_목록을_조회_한다,
    프로젝트를_생성_한다: async () => false, // 구현 필요
    setProjects,
  };

  return (
    <ProjectManagementContext.Provider value={contextValue}>
      {children}
    </ProjectManagementContext.Provider>
  );
};

export const useProjectManagement = () => {
  const context = useContext(ProjectManagementContext);
  if (context === undefined) {
    throw new Error(
      "useProjectManagement must be used within a ProjectManagementProvider"
    );
  }
  return context;
};
```

### 페이지 컴포넌트 예시

```typescript
// page.tsx
import { ProjectManagementProvider } from "./_context/ProjectManagementContext";
import PageContent from "./_ui/PageContent";

export default function AllProjectsPage() {
  return (
    <ProjectManagementProvider>
      <PageContent />
    </ProjectManagementProvider>
  );
}
```

## 13. 핵심 원칙

1. **관심사 분리**: Context는 데이터, Page는 UI 상태
2. **한국어 네이밍**: 액션 함수는 한국어 동사형 사용
3. **에러 처리**: 모든 API 호출에 적절한 에러 처리
4. **타입 안전성**: TypeScript 타입 정의 철저히
5. **재사용성**: 커스텀 훅으로 Context 사용 추상화
6. **일관성**: API 라우트 구조와 네이밍 패턴 통일
7. **사용자 경험**: 한국어 에러 메시지와 적절한 로딩 상태
8. **폴더 구조**: `_context/`, `_ui/`, `_hooks/` 명명 규칙 준수
9. **컴포넌트 분류**: `.panel/`, `.section/`, `.module.tsx`, `.component.tsx` 구분 사용
10. **경로 일관성**: 페이지 경로와 API 경로 매핑 규칙 준수 (`/plan/{module}/{page}` ↔ `/api/{module}/{page}`)
11. **데이터 흐름**: Context → Route Handler → 컴포넌트 훅 사용 패턴 준수
